<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
  <info>
    <title>Patterns for Translating XML to RDF</title>
    <subtitle>A framework for translating XML information to RDF</subtitle>
    <keywordset>
      <keyword>xml</keyword>
      <keyword>rdf</keyword>
      <keyword>semantic web</keyword>
      <keyword>schema</keyword>
      <keyword>ontology</keyword>
      <keyword>xsd</keyword>
      <keyword>owl</keyword>
      <keyword>schematron</keyword>
      <keyword>xslt</keyword>
      <keyword>xquery</keyword>
    </keywordset>
    <abstract>
      <para></para>
    </abstract>
  </info>
  <section>
    <title>Introduction</title>
    <para>The common models for information storage mainly fall into the categories of tables, trees
      and graphs. Where organisations are seeking fresh insights into relationships between entities
      and information, that are stored in relational tables, they are now frequently turning to
      graph models, like RDF, to organise and query relationships. Whilst specifications, and tools
      that implement them, already exist for Relational to RDF mappings the same cannot so easily be
      said for XML.</para>
    <para>Whilst programmatic solutions, written in XSLT or XQuery for example, are often used, it
      is quite often more desirable to use a Domain Specific Language that will provide a cleaner
      mechanism for defining the binding of XML nodes to ontology terms.</para>
    <para>As an example, when dealing with publications there is, usually embedded within the
      document, metadata that describes simple properties of the document like revision and subject
      categories. The metadata may also identify agents (authors, editors, publishers and the like)
      who have played some part in shaping the content of the publication. Lifting such information
      out of the document and away from document centric query languages and into the broader realm
      of RDF affords the same opportunities for discovering and managing relationships across a
      wider range of information.</para>
    <para/>
    <para><!--Apart from implementing the mapping in a programmatic fashion, which renders the solution implementation dependant, the relational mapping processes can follow either a direct approach where the vocabulary terms are derived directly from the column names or, alternatively, one can create explicit mappings between column names and a target ontology. XML mappings to RDF can also follow both the programmatic and direct mapping routes and be hindered by the same short comings. However, XML has to alternate routes that are built on grammar and rule based mechanisms.--></para>
  </section>
  <section>
    <title>Context is everything</title>
    <para>Of all the things you need to do when mapping XML data to RDF, first and foremost you need
      to establish which nodes contain the information you wish to map. There are two ways in which
      we can identify a context in an XML document, by grammar or by rules.</para>
    <section>
      <title>Context from grammar</title>
      <para>If you have a schema then you have the opportunity of defining nodes and their
        associated simple and complex types. If modelled wisely then there should be sufficient
        granularity for occurrences of nodes in a conforming XML document to apply a mapping between
        the nodes and terms defined in the target ontology. The mapping definition comes from
        annotating a schema, at the node or type declaration level, with references to the target
        ontology's property and type definitions. </para>
    </section>
    <section>
      <title>Context from rules</title>
      <para>In the absence of a schema you can also identify context in a document using XPath
        location paths. What we are attempting to achieve here is the identification of specific
        nodes or repeating occurrences of nodes that we wish to map to terms in an ontology. XPath
        provides us with the syntax for expressing the context and all we then need is a way to
        define the mapping.</para>
      <para/>
    </section>
  </section>
  <section>
    <title>Grammar based mapping</title>
    <para>There is already in existence a W3C Recommendation that defines how such mapping
      annotations can be made and was first defined within the Web Services Stack as Semantic
      Annotations for WSDL and XML Schema (SAWSDL). The generalised term for the process of applying
      a mapping in this way is 'Schema Lifting'. There are a number of practical pros and cons to
      this approach that we will discuss later when we compare it to the rules based
      approach.</para>
  </section>
  <section>
    <title>Rule based mapping</title>
    <para>Mappings between XML nodes and ontology terms are in actuality composed of four
      parts:</para>
    <itemizedlist>
      <listitem>
        <para>Context</para>
      </listitem>
      <listitem>
        <para>Subject</para>
      </listitem>
      <listitem>
        <para>Predicate</para>
      </listitem>
      <listitem>
        <para>Object</para>
      </listitem>
    </itemizedlist>
    <para>The first part identifying which node contains the information you want to transfer, the
      other three make up the RDF triple. Looking at the predicate first, this is a static mapping
      as all that is required is to state the property you are mapping to. The subject and object If
      we approach the mapping in this way we have quite a lot of flexibility in how we achieve
      this</para>
  </section>
  <section>
    <title>How do the two approaches compare?</title>
    <para></para>
  </section>
  <section>
    <title>Future Work</title>
    <para></para>
  </section>
  <section>
    <title>Summary and Conclusions</title>
    <para></para>
  </section>
  <!--<bibliography xml:id="references">
    <title>References</title>
    
  </bibliography>-->
</article>
